<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Ideation2 - Design System & Prototyping</title>
  <link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>
    <div class="left"><a href="index.html">FishOn</a></div>
    <div class="center">
      <a href="about.html">About</a>
      <a href="log.html">Log</a>
    </div>
    <!-- <div class="right"><a href="index.html">← Back to Gallery</a></div> -->
  </header>

  <main>
    <section class="about-landing">
      <div class="label-container">
        <span class="label outline">Multi-sensor Physicalization</span>
        <span class="label outline">Community</span>
        <span class="label outline">Play</span>
      </div>

      <div class="context">
        While FishOn already <bold>digitalizes the market for younger users,</bold>it still lacks a natural flow to guide them before, during, and after their trips. Young anglers often face fragmented knowledge and steep learning curves, especially when fishing within limited time. 
        <br>
        <br>
        Our goal is to make the experience more organized, reduce disappointment from empty catches, and ensure fishing remains fun and efficient.
      </div>

      <div class="hmw">
        HMW create a natural, seamless flow that guides users before, during, and after fishing trips?
      </div>
      <div class="scroll-down">
        <button class="title-arrow" onclick="scrollToNextSection()" aria-label="Scroll to next section">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M6 9l6 6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>
    </section>

      <!-- Earth Visualization Section -->
      <div class="earth-section">
        <div class="earth-container">
          <div class="earth-layers">
            <canvas id="layer-bottom" class="earth-layer" data-layer="bottom" width="675" height="675"></canvas>
            <canvas id="layer-middle" class="earth-layer" data-layer="middle" width="675" height="675"></canvas>
            <canvas id="layer-top" class="earth-layer" data-layer="top" width="675" height="675"></canvas>
          </div>
        </div>
        
        <div class="earth-content">
          <div class="earth-info" id="earth-info">
            <div class="info-item active" data-layer="bottom">
              <h2>2D Map Interface</h2>
              <ul>
                <li>Recommendation engine</li>
                <li>Community-marked fishing spots</li>
                <li>Real-time weather overlays & ideal time suggestions</li>
                <li>Route planning and GPS-based navigation</li>
              </ul>
            </div>
            <div class="info-item" data-layer="middle">
              <h2>2.5D Map Interface — Emotion & Discovery Map</h2>
              <ul>
                <li>Unlock & track regional fish species</li>
                <li>Check-in system with badges & rewards</li>
                <li>Encouragement system via motivational popups</li>
                <li>Beginner-friendly suggestion cards</li>
              </ul>
            </div>
            <div class="info-item" data-layer="top">
              <h2>4D XR Map Interface</h2>
              <ul>
                <li>Visual reconstruction of fish spots via 3D scanning</li>
                <li>AR-based immersive previews</li>
                <li>Fish species terrain recognition with AI guidance</li>
                <li>Species detection & highlight moment replay</li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      <!-- Parallax Section -->
      <div class="parallax-container" id="parallax-container">
         <div class="parallax-wrapper">
           <img src="Photo/bottom_layer.png" alt="Bottom Layer Parallax" class="parallax-image" id="parallax-image">
           <svg class="progress-ring" width="675" height="675">
             <circle class="progress-circle-bg" cx="337.5" cy="337.5" r="335.5" fill="none" stroke="#333" stroke-width="2"/>
             <circle class="progress-circle progress-section-1" cx="337.5" cy="337.5" r="335.5" fill="none" stroke="#ffffff" stroke-width="5" stroke-dasharray="703" stroke-dashoffset="703"/>
             <circle class="progress-circle progress-section-2" cx="337.5" cy="337.5" r="335.5" fill="none" stroke="#ffffff" stroke-width="5" stroke-dasharray="703" stroke-dashoffset="703"/>
             <circle class="progress-circle progress-section-3" cx="337.5" cy="337.5" r="335.5" fill="none" stroke="#ffffff" stroke-width="5" stroke-dasharray="703" stroke-dashoffset="703"/>
           </svg>
           <div class="parallax-titles">
             <div class="title-text title-1">2D Map Interface</div>
             <div class="title-text title-2">2.5D Map Interface — Emotion & Discovery Map</div>
             <div class="title-text title-3">4D XR Map Interface</div>
           </div>
         </div>
       </div>
       
       <!-- Spacer to allow scrolling through entire parallax section -->
       <div style="height: 100vh; background-color: #000000;"></div>
   </main>

   <script>
    // Initialize when DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      initEarthInteraction();
      initStickyEffect();
    });

    function scrollToNextSection() {
      const next = document.querySelector('.earth-section');
      if (next) {
        next.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }

    // 实现滚动时的视差效果
    function initStickyEffect() {
      const parallaxWrapper = document.querySelector('.parallax-wrapper');
      const parallaxContainer = document.getElementById('parallax-container');
      const earthSection = document.querySelector('.earth-section');
      const earthLayers = document.querySelector('.earth-layers');
      const progressRing = document.querySelector('.progress-ring');
      const progressSections = document.querySelectorAll('.progress-circle');
      const titleTexts = document.querySelectorAll('.title-text');
      
      if (!parallaxWrapper || !parallaxContainer || !earthSection || !earthLayers || !progressRing) return;
      
      // 获取earth-section的底部位置
      const earthSectionBottom = earthSection.offsetTop + earthSection.offsetHeight;
      const viewportHeight = window.innerHeight;
      let hasStartedParallax = false;
      
      function handleScroll() {
        const scrollY = window.scrollY;
        const earthSectionTop = earthSection.offsetTop;
        const earthSectionBottom = earthSectionTop + earthSection.offsetHeight;
        const parallaxStartY = earthSectionBottom;
        const parallaxEndY = parallaxStartY + (viewportHeight * 3);
        
        // 当earth-section完全进入视窗时，显示图像在初始位置
        if (scrollY >= earthSectionTop && scrollY < parallaxStartY) {
          parallaxWrapper.className = 'parallax-wrapper initial';
          earthLayers.classList.remove('hidden'); // 显示原始圆圈
          progressRing.classList.remove('visible'); // 隐藏进度条
          titleTexts.forEach(title => title.classList.remove('visible')); // 隐藏所有标题
          hasStartedParallax = false;
        }
        // 当进入视差区域时，滑动到中心并隐藏原始圆圈
        else if (scrollY >= parallaxStartY && scrollY <= parallaxEndY) {
          parallaxWrapper.className = 'parallax-wrapper center';
          
          // 一旦开始视差效果，就隐藏原始圆圈并显示进度条
          if (!hasStartedParallax) {
            earthLayers.classList.add('hidden');
            progressRing.classList.add('visible');
            hasStartedParallax = true;
          }
          
          // 每次都重新触发进度条动画
          progressRing.classList.add('visible');
          animateProgressBars();
          
          // 根据滚动进度显示不同的标题
          const progress = (scrollY - parallaxStartY) / (viewportHeight * 3);
          const scale = 1 + (progress * 0.1); // 从1.0轻微缩放到1.1
          parallaxWrapper.style.transform = `translate(-50%, -50%) scale(${scale})`;
          
          // 控制标题显示
          updateTitles(progress);
        }
        // 超过视差区域时，隐藏图像并恢复原始圆圈
        else if (scrollY > parallaxEndY) {
          parallaxWrapper.className = 'parallax-wrapper';
          earthLayers.classList.remove('hidden'); // 恢复显示原始圆圈
          progressRing.classList.remove('visible'); // 隐藏进度条
          titleTexts.forEach(title => title.classList.remove('visible')); // 隐藏所有标题
          hasStartedParallax = false;
        }
        // 在earth-section之前，完全隐藏图像
        else {
          parallaxWrapper.className = 'parallax-wrapper';
          earthLayers.classList.remove('hidden'); // 确保原始圆圈可见
          progressRing.classList.remove('visible'); // 确保进度条隐藏
          titleTexts.forEach(title => title.classList.remove('visible')); // 隐藏所有标题
          hasStartedParallax = false;
        }
      }
      
       // 更新标题显示函数
       function updateTitles(progress) {
         const parallaxImage = document.querySelector('.parallax-image');
         
         // 隐藏所有标题
         titleTexts.forEach(title => {
           title.classList.remove('visible');
         });
         
         // 移除所有颜色类
         parallaxImage.classList.remove('color-bottom', 'color-middle', 'color-top');
         
         // 根据滚动进度显示对应的标题和颜色
         if (progress >= 0 && progress < 0.33) {
           // 第一个窗口高度：显示第一个标题 - 蓝色（bottom层）
           titleTexts[0].classList.add('visible');
           changeImageWithTransition('../Photo/bottom_layer.png');
           console.log('切换到蓝色图片, progress:', progress);
         } else if (progress >= 0.33 && progress < 0.66) {
           // 第二个窗口高度：显示第二个标题 - 浅紫色（middle层）
           titleTexts[1].classList.add('visible');
           changeImageWithTransition('../Photo/buttom2.png');
           console.log('切换到buttom2图片, progress:', progress);
         } else if (progress >= 0.66) {
           // 第三个窗口高度：显示第三个标题 - 绿色（top层）
           titleTexts[2].classList.add('visible');
           changeImageWithTransition('../Photo/buttom3.png');
           console.log('切换到buttom3图片, progress:', progress);
         }
         
         // 调试信息
         console.log('当前进度:', progress, '第三个标题可见:', titleTexts[2].classList.contains('visible'));
       }
       
       // 带过渡效果的图片切换函数
       function changeImageWithTransition(newSrc) {
         const parallaxImage = document.querySelector('.parallax-image');
         if (parallaxImage.src.includes(newSrc)) return; // 如果已经是目标图片，不重复切换
         
         // 淡出
         parallaxImage.style.opacity = '0.3';
         parallaxImage.style.transform = 'scale(0.95)';
         
         setTimeout(() => {
           // 切换图片
           parallaxImage.src = newSrc;
           
           // 淡入
           parallaxImage.style.opacity = '1';
           parallaxImage.style.transform = 'scale(1)';
         }, 300); // 300ms后切换图片
       }
      
      // 进度条动画函数
      let animationTimeout;
      function animateProgressBars() {
        // 清除之前的动画
        if (animationTimeout) {
          clearTimeout(animationTimeout);
        }
        
        // 首先重置所有进度条到初始状态
        progressSections.forEach((section) => {
          section.style.strokeDashoffset = '703';
        });
        
        // 然后依次动画每个进度条
        progressSections.forEach((section, index) => {
          setTimeout(() => {
            section.style.strokeDashoffset = '0';
          }, index * 500); // 每个进度条间隔500ms动画
        });
      }
      
      // 初始化时确保图像处于隐藏状态
      parallaxWrapper.className = 'parallax-wrapper';
      
      // 监听滚动事件
      window.addEventListener('scroll', handleScroll);
      
      // 初始检查
      handleScroll();
    }

    // Data URI constants for the three layers
    const LAYER_DATA = {
      bottom: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAAAAAQACAYAAAB/HSuDAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAE3NSURBVHgB7d3LdlzltS/w+a2yfAinsZWmx5bZJRnGSC/mCSI3LHucTswTYJ7A5gkwT4B5AswToHRyZNNAeQKcHmPgSwUrcTO1GwfYlmp9p5YsGd91q8u6/H5jbKpUqthhx4ia/2/O+aUAAGauf+Xh4ju/vrNYPd+JnX71mCP197+fy/z0eUr/kSIWn/+PPv/r5Je+fu4br3/9sFIMXv/yK68PfvstYxg5//fTN6ZhSuOvy3KYijTcfWn82Ct7wx82zrz21wYApisFAHAif7j8uF89VoX8fhG/W8D/Vrz3cx4/pr1C/qTFeXsMx/8/GT4XKgyehQhVgJDLQRUaCA4AYDIEAADwBlVhv1/U7xbwEf/1rKDfP3lXzM9a1U0w2O0uqAKDnP/xfFhwKk4NBAUA8HoCAAA6qSruR8VosSzj/G/FfVXo77beV/+3GDTZXlCQBjnyoOoqSJHvViHBzjs7dwfry8MAgI4RAADQStWM/cKThf5+gT/+F94fx//aWxwXg+fjacGvwOdu1UmQx4/j5/+ougiKU8Vg+/T2QEAAQBsJAABorP1FetsxWt0v8seP53dn7bXmczLVEsMqGNgdM6i6B6pw4Me/Lt0NAGgoAQAAtffSaf4fd1v1n57k9wNm74XOgSLlu8YKAGgCAQAAtaHQp+F2uwaqYCDl8m/VvoF7G2c3AwBqQgAAwFxUS/i2y+3zORX93db9iFWFPi11d3cZYS7/XhSx6aYCAOZFAADA1O0W+0/n9P+4t2l/NSzho9te6BawXwCAWRAAADBRLxb7u63850OxD4fxQiiwUCzc1SkAwCQJAAA4tmpm/9...',
      middle: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAAAAAQACAYAAAB/HSuDAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUACAMZSURBVHgB7P3dsyXJcSeIuUeec++tr/4ApwBi2RSKWIga67EZ9hrN1kz7goJsSe6YyYzAkE3JTCYB86Y3YEd/QHXNHzAg/wGhYbsP0jQwjTGjCQtgbLrwIDM9DDXNh20bURRQGDTRBIpgd6M+7r3nZEbI3SMiT2RkRGaeW99V/uu+dfJkRkZERkac8J+7hweCQqFQKBSKx4Lvvv3BFf5stt1LiO4ly38WXuJzBlGugTEOAa5YcGDoq3P4EgKlc47T0FmgdPRpnSRHyoi+0i3uCvJ152JxfIBJ8S5cx+xaPL7pv8bL8vER3fIR1QmAKhou9+ko5U1rLUqdO/cTucXZj4zBj1r+slpJ2n/6pU/fBIVCoVAoFI8cCAqFQqFQKO4Lb7/945eO4OglaNsrhkg8WvOSa/AzRH9fIv4thB2weZFY+m8FQn0luT0S7hFBD59YSLsIrAwIBH9wPFV2JV0pr7xuS5E+w81eqeBzu0kXPwLrPkaHN50h5YEj5QEpDk7g5KMvfem3PgKFQqFQKBRnhioAFAqFQqGogC30bJ0nInpFSD2SVd2YzzCpZxLvyFqPhi3wPYTc5iQ6s8T36bJ75DixyAMMyXlJITDIM7HoL0JSz5ECIK2PeBX4L7V6lBQTLjREXtbeiO0neVi4iQ3+RDwQRGGAN9nboEN3k9OerNp3VVGgUCgUCkUZqgBQKBQKxXOJaLU33fY1b7GH36FJ8SWisle8Wz2QBb8n8+mtI+I+5WYPY9f6RVb27HyuQCjBFeoHSZmjeub5zigq9oFL8iqVP3kv1J8hbR9XyzvoHX6CBm+6tvvINOZduu0jdN...',
      top: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAAAAAQACAYAAAB/HSuDAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUABqJtSURBVHgB7P1djxxXliWIni/78PBwkpFkSBRb6lSzs1nZjFu4aAg9BdSti+QA8zSoeYwE+u0+9UP/iYj4E/nQf2AAxWPdx7p3mEBPA4WGULioIdHFzuFVtrIoSkEqGPTwcPs658xe+xzz8AiSSkmZKSlTewWdZm5ubm5uEWZ29tprr62UQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgE3zK0EggEAoHgjxM6xjjOR03Ac0yUQCAQCAQCgeAVCAEgEAgEgu8dKJDn+1MO5lNgj1uWVpF+NP4b5/kN+H8t7Nd5cRwX0rq0bJ0wEKJAIBAIBALBDw5OCQQCgUDw/cAqg69zdI8Af/9gn8N7PD/YPzC8Iq+aSIKDgwOt9jGztqW9FPnjtf29vRVpgOd7+3sRn8DvzySCkAECgUAgEAh+CBAFgEAgEAi+U+SsvF7dkWJ6EtdS+jnS12pvP4IQuHv3rj5Uh2rn4U5aaU9dJAAID2idnd2HtD5e31vl/pkw4EV78Xz7WV3wipZAIBAIBAKB4E8HQgAIBAKB4DsDgn8KyA2C8QNF2Xm1t2IDOPNPgf3dw7v6IQXyDw4f6N3dXXV4SIH/9g7fvx4cPbgQrGP5K8t2M0mwRhDsE...'
    };

    // Earth layer interaction functionality
    function initEarthInteraction() {
      const canvases = document.querySelectorAll('.earth-layer');
      const infoItems = document.querySelectorAll('.info-item');
      const earthLayersContainer = document.querySelector('.earth-layers');
      
      // 初始化：显示bottom层内容
      showInfoForLayer('bottom');
      
      // 设置canvas
      setupCanvases();
      
      function setupCanvases() {
        const imageFiles = {
          'bottom': 'Photo/buttom.png',
          'middle': 'Photo/middle.png', 
          'top': 'Photo/top.png'
        };
        
        canvases.forEach(canvas => {
          const layerType = canvas.getAttribute('data-layer');
          const ctx = canvas.getContext('2d');
          
          // 设置canvas尺寸
          canvas.width = 675;
          canvas.height = 675;
          
          // 加载对应的PNG图片
          const img = new Image();
          img.onload = function() {
            // 清空canvas
            ctx.clearRect(0, 0, 675, 675);
            // 绘制图片
            ctx.drawImage(img, 0, 0, 675, 675);
          };
          img.src = imageFiles[layerType];
        });
      }
      
      // 使用mousemove事件来检测鼠标位置
      earthLayersContainer.addEventListener('mousemove', function(e) {
        const rect = this.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // 检查是否在地球范围内
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        const distance = Math.sqrt(
          Math.pow(mouseX - centerX, 2) + Math.pow(mouseY - centerY, 2)
        );
        const radius = rect.width / 2;
        
        if (distance > radius) {
          return; // 鼠标在地球外
        }
        
        // 使用基于区域的检测
        const detectedLayer = detectLayerByRegion(mouseX, mouseY, rect);
        showInfoForLayer(detectedLayer);
      });
      
      function detectLayerByRegion(mouseX, mouseY, rect) {
        // 将鼠标位置转换为相对坐标 (0-1)
        const x = mouseX / rect.width;
        const y = mouseY / rect.height;
        
        // 计算距离中心的相对距离
        const centerX = 0.5;
        const centerY = 0.5;
        const distanceFromCenter = Math.sqrt(
          Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2)
        );
        
        // 使用更精确的区域检测，基于实际图片内容
        // 根据PNG图片的实际布局来优化检测
        
        // 边缘区域 (距离中心 > 40%) - 蓝色海洋
        if (distanceFromCenter > 0.4) {
          return 'bottom';
        }
        // 外围区域 (距离中心 25-40%) - 大陆边缘
        else if (distanceFromCenter > 0.25) {
          // 在特定角度范围内检测大陆
          const angle = Math.atan2(y - centerY, x - centerX);
          const angleDeg = (angle * 180 / Math.PI + 360) % 360;
          
          // 大陆通常在特定角度范围内
          if ((angleDeg > 30 && angleDeg < 150) || 
              (angleDeg > 210 && angleDeg < 330)) {
            return 'middle';
          } else {
            return 'bottom';
          }
        }
        // 中心区域 (距离中心 < 25%) - 城市密集区
        else {
          return 'top';
        }
      }
      
      function showInfoForLayer(layerType) {
        // 隐藏所有文字内容
        infoItems.forEach(item => {
          item.classList.remove('active');
        });
        
        // 显示对应的文字内容
        const targetInfo = document.querySelector(`.info-item[data-layer="${layerType}"]`);
        if (targetInfo) {
          targetInfo.classList.add('active');
        }
        
        // 调试信息（可以在控制台查看）
        console.log('当前显示图层:', layerType);
      }
    }
  </script>
</body>
</html>

