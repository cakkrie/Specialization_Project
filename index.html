<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>About</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Raleway:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="style.css">


  <!-- jsPlumb Toolkit CSS -->
  <script src="node_modules/@jsplumbtoolkit/browser-ui/js/jsplumbtoolkit.browser-ui.umd.js"></script>
  <link rel="stylesheet" href="node_modules/@jsplumbtoolkit/browser-ui/css/jsplumbtoolkit.css">
  <link rel="stylesheet" href="app.css">
 </head>
<body>
  <header>
    <div class="left"><a href="index.html">FishOn</a></div>
    <div class="center">
      <a href="about.html">About</a>
      <a href="research.html">Research</a>
    </div>
  </header>

  <main>
    <section class="landing-page">
      <div class="landing-page-title">
        <div class="main-title">
          <div class="title-line">YOUR</div>
          <div class="title-line">FISHING GUIDE</div>
          <div class="title-line">INTELLIGENCE</div>
        </div>
        <div class="subtitle">Blend emotional support, real data, <br>
          and a gamified journey on every trip.</div>
      </div>
      <div class="cta">
        <a href="#landing-context" class="title-cta">
          <span class="cta-icon" aria-hidden="true">↳</span>
          <span class="cta-text">SEE WHAT WE DO</span>
        </a>
      </div>
    </section>

    <section class="landing-context" id="landing-context">
      <div class="landing-context-pin">
        <img src="Photo/main-page/fish-background.jpg" alt="Fishing background" class="about-bg">
          <div class="overlay header-2xl" id="market-intro">
            The global fishing market continues to expand steadily, driven by rising seafood demand, growing recreational participation, and advances in aquaculture.
          </div>

        <div class="overlay header-2xl" id="mid-note" aria-hidden="true">
            In the recreation fishing, more and more yonger anglers are entering the market due to the change of lifestyle. 
        </div>

        <div class="overlay trend-row" id="trend-row" aria-hidden="true">
          <div class="overlay trend-card" id="young-trend" aria-hidden="true">
            <h3>Lack of experience</h3>
            <p>The growing participation among Gen Z usually don't have much experience and need help from friends to guide them on fishing.</p>
          </div>
          <div class="overlay trend-card" id="rely-tech" aria-hidden="true">
            <h3>Rely on technology</h3>
            <p>Mobile apps, sonar, and AI-driven insights increasingly guide spot selection and tactics.</p>
          </div>
          <div class="overlay trend-card" id="limited-time" aria-hidden="true">
            <h3>Limited time on fishing</h3>
            <p>Busy schedules push for efficient, outcome-oriented trips and bite-time optimization.</p>
          </div>
        </div>
      </div>
    </section>

    <section class="hmw-section">
      <div class="hmw-container">
        <div class="header-xl">How might we design a tool</div>
        <div class="header-6xl">for younger anglers</div>
        <div class="header-2xl">In the digitalized era?</div>
      </div>
    </section>

    <section class="bubble-section">
      <div id="bubble-field" class="bubble-field" aria-live="polite"></div>
      <br>
      <br>
      <br>
      <div class="cta">
        <a href="fishing-community.html" class="title-cta" aria-label="Explore Fishing Community">
          <span class="cta-icon" aria-hidden="true">↳</span>
          <span class="cta-text">EXPLORE FISHING COMMUNITY</span>
        </a>
      </div>
    </section>

    <section class="list-light">
      <div class="header-3xl">Map of <br>Community</div>
      <br>
      <section class="list">
        <div class="list-row">
          <div class="header-3xl">01</div>
          <div class="header-2xl">Software</div>
          <div class="row-labels"><span class="label">Software</span></div>
          <button class="toggle" onclick="toggleRow(this)" aria-label="Toggle details"></button>
        </div>
        <div class="list-row-content">
          <p>An app that analyzes data points — including satellite imagery, weather patterns, water depth data, and historical fishing records to generate fish activity forecasts, hotspot maps, and water clarity maps.</p>
        </div>

        <div class="list-row">
          <div class="caption-base">(02)</div>
          <div class="body-sm">Fishbuddy</div>
          <div class="row-labels"><span class="label">Software</span></div>
          <button class="toggle" onclick="toggleRow(this)" aria-label="Toggle details"></button>
        </div>
        <div class="list-row-content">
          <p>Smart decisions: uses 10+ weather factors (temp, pressure, humidity) to flag prime times, recommend bait, and navigate nearby spots. Social: in-app forum to share catches and techniques.</p>
        </div>

        <div class="list-row">
          <div class="caption-base">(03)</div>
          <div class="body-sm">墨迹天气</div>
          <div class="row-labels"><span class="label">Software</span></div>
          <button class="toggle" onclick="toggleRow(this)" aria-label="Toggle details"></button>
        </div>
        <div class="list-row-content">
          <p>Expert-verified with hi-res satellite and depth maps. AR+AI logging: snap a fish to auto-record species, size/weight, location, and weather. AR contests: create/join casual challenges with live leaderboards.</p>
        </div>

        <div class="list-row">
          <div class="caption-base">(04)</div>
          <div class="body-sm">Sea.ai</div>
          <div class="row-labels"><span class="label">Hardware</span></div>
          <button class="toggle" onclick="toggleRow(this)" aria-label="Toggle details"></button>
        </div>
        <div class="list-row-content">
          <p>Smart camera: combines optical and infrared sensors, utilizes AI and ML algorithms to detect objects on the water surface.</p>
        </div>

        <div class="list-row">
          <div class="caption-base">(05)</div>
          <div class="body-sm">Chasing F1 Pro</div>
          <div class="row-labels"><span class="label">Hardware</span></div>
          <button class="toggle" onclick="toggleRow(this)" aria-label="Toggle details"></button>
        </div>
        <div class="list-row-content">
          <p>Remote/autonomous lateral movement, station-hold, multi-spot waypoints. Depth &amp; temperature sensors; Wi‑Fi streams live video + depth/temp to the app. Bait-boat mount with one-tap in-app bait release.</p>
        </div>
      </section>
    </section>

    <br>
    <br>
    <br>


    <div class="header-4xl primary">How it works</div>
    <div class="body-sm" style="text-align: center;">An uml diagram of the specilized fishing map</div>
  

    <section class="uml-section">
      <div class="uml-diagram-container" id="uml-diagram">
        <!-- UML cards will be dynamically generated from JSON data -->
      </div>
    </section>

      <!-- Earth Visualization Section -->
    <div class="earth-section">
      <div class="earth-container">
        <div class="earth-layers">
          <canvas id="layer-bottom" class="earth-layer" data-layer="bottom" width="675" height="675"></canvas>
          <canvas id="layer-middle" class="earth-layer" data-layer="middle" width="675" height="675"></canvas>
          <canvas id="layer-top" class="earth-layer" data-layer="top" width="675" height="675"></canvas>
        </div>
      </div>
        
      <div class="earth-content">
        <div class="earth-info" id="earth-info">
          <div class="info-item active" data-layer="bottom">
            <h2 class="header-md">2D Map Interface</h2>
            <ul>
              <li>Recommendation engine</li>
              <li>Community-marked fishing spots</li>
              <li>Real-time weather overlays & ideal time suggestions</li>
              <li>Route planning and GPS-based navigation</li>
            </ul>
          </div>
          <div class="info-item" data-layer="middle">
            <h2 class="header-md">2.5D Map Interface</h2>
            <ul>
              <li>Unlock & track regional fish species</li>
              <li>Check-in system with badges & rewards</li>
              <li>Encouragement system via motivational popups</li>
              <li>Beginner-friendly suggestion cards</li>
            </ul>
          </div>
          <div class="info-item" data-layer="top">
            <h2 class="header-md">4D XR Map Interface</h2>
             <ul>
              <li>Visual reconstruction of fish spots via 3D scanning</li>
              <li>AR-based immersive previews</li>
              <li>Fish species terrain recognition with AI guidance</li>
              <li>Species detection & highlight moment replay</li>
            </ul>
          </div>
        </div>
      </div>
    </div>

       <!-- Parallax Section -->
    <div class="parallax-container" id="parallax-container">
      <div class="parallax-wrapper">
        <img src="Photo/bottom_layer.png" alt="Bottom Layer Parallax" class="parallax-image" id="parallax-image">
            
            <!-- Phone screens in the center -->
        <div class="screen-container">
          <img src="Photo/buttom1_screen.png" alt="Screen 1" class="phone-screen screen-1">
          <img src="Photo/buttom2_screen.png" alt="Screen 2" class="phone-screen screen-2">
          <img src="Photo/buttom3_screen.png" alt="Screen 3" class="phone-screen screen-3">
        </div>
            
        <svg class="progress-ring" width="675" height="675">
          <circle class="progress-circle-bg" cx="337.5" cy="337.5" r="335.5" fill="none" stroke="#333" stroke-width="2"/>
          <circle class="progress-circle progress-section-1" cx="337.5" cy="337.5" r="335.5" fill="none" stroke="#ffffff" stroke-width="1.5" stroke-dasharray="703" stroke-dashoffset="703"/>
          <circle class="progress-circle progress-section-2" cx="337.5" cy="337.5" r="335.5" fill="none" stroke="#ffffff" stroke-width="1.5" stroke-dasharray="703" stroke-dashoffset="703"/>
          <circle class="progress-circle progress-section-3" cx="337.5" cy="337.5" r="335.5" fill="none" stroke="#ffffff" stroke-width="1.5" stroke-dasharray="703" stroke-dashoffset="703"/>
        </svg>
        <div class="parallax-titles">
          <div class="title-text title-1"><span>2D Map</span><span class="title-sub">Real-time overlays and navigation</span><span class="title-body">A data-driven map that visualizes real fishing spots, weather, and location information for quick decision-making</span></div>
          <div class="title-text title-2"><span>2.5D Map</span><span class="title-sub">Emotion & Discovery Map</span><span class="title-body">A semi-immersive map blending 3D depth and emotional feedback, exploration through ambient visuals.</span></div>
           <div class="title-text title-3"><span>4D XR Map</span><span class="title-sub">Immersive XR previews</span><span class="title-body">An extended-reality environment that anchors fish and environment in real-world space, merging physical and virtual fishing experiences.</span></div>
        </div>
      </div>
    </div>
       
       
       <!-- Grey Card Section (3vh spacing from bottom) -->
    <section class="bottom-card-section">
      <div class="header-4xl primary">Radical Prototype</div>
      <div class="body-sm" style="text-align: center;">Letting users to "see" the dynamic fish habitats and real-time encouragement from an AI multidimensional agent, creating an immersive yet emotionally supportive fishing journey</div>
        <div class="grey-card" id="tiltCard">
          <div class="card-text">
            <p>Letting users to "see" the dynamic fish habitats and real-time encouragement from an AI multidimensional agent, creating an immersive yet emotionally supportive fishing journey</p>
          </div>
        </div>
      </div>
    </section>
       
       <!-- Responsive Cards Grid Section -->
    <section class="responsive-cards-section">
      <div class="responsive-cards-grid">
        <div class="responsive-card">
          <div class="header-xl">Fishing Tech</div>
             div class="responsive-card-description">Envisions a future where fishing blends data, emotion, and nature to explore new nature–AI relationships.</div>
          </div>
          <div class="responsive-card">
            <div class="header-xl">Provocative</div>
            <div class="responsive-card-description">Balance tech's focus on efficiency and experience with emphasizing mindfulness, emotion, and play.</div>
          </div>
          <div class="responsive-card">
            <div class="header-xl">Narrative-driven</div>
            <p>Builds a story between user, environment and community through every fishing journey.</p>
          </div>
          <div class="responsive-card">
            <div class="header-xl">Experience over functional</div>
            <p>Focuses on illustrating ideas of journey while blending technical completion.</p>
          </div>
          <div class="responsive-card">
            <div class="header-xl">Speculative</div>
            <p>Connects speculative storytelling with design research to reflect on the fishing community.</p>
          </div>
        </div>
      </div>
    </section>
  </main>

  <script>
    // Initialize when DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      initEarthInteraction();
      initStickyEffect();
      initAboutLanding2Scroll();
      initTiltCard();
    });
    
    // Tilt card effect
    function initTiltCard() {
      const card = document.getElementById('tiltCard');
      if (!card) return;
      
      // On hover: straighten the card
      card.addEventListener('mouseenter', function() {
        card.classList.add('hovered');
      });
      
      card.addEventListener('mouseleave', function() {
        card.classList.remove('hovered');
      });
    }

    function scrollToAbout() {
      const target = document.querySelector('.landing-context');
      if (target) {
        target.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }


    // Scroll-based animation functionality
    function initScrollAnimations() {
      const cards = document.querySelectorAll('.project-card');
      
      // Intersection Observer for fade-in animation
      const observerOptions = {
        threshold: 0.2,
        rootMargin: '0px 0px -50px 0px'
      };

      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const cardIndex = Array.from(cards).indexOf(entry.target);
            // Stagger animation with increasing delay
            setTimeout(() => {
              entry.target.classList.add('animate-in');
            }, cardIndex * 100);
          }
        });
      }, observerOptions);

      // Observe all cards
      cards.forEach(card => {
        observer.observe(card);
      });
    }

    // Initialize animations and load header when DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      if (typeof loadHeader === 'function') {
        loadHeader();
      }
      initScrollAnimations();
    });

    // Sticky scroll control for landing-context (2500px total pin, 5 stages)
    function initAboutLanding2Scroll() {
      const section = document.querySelector('.landing-context');
      const pin = document.querySelector('.landing-context-pin');
      const intro = document.getElementById('market-intro');
      const midNote = document.getElementById('mid-note');
      const trendRow = document.getElementById('trend-row');
      const card1 = document.getElementById('young-trend');
      const card2 = document.getElementById('rely-tech');
      const card3 = document.getElementById('limited-time');
      if (!section || !pin || !intro || !midNote || !trendRow || !card1 || !card2 || !card3) return;

      const SCROLL_LENGTH = 2500; // total pinned scroll distance in px

      // Ensure section height supports sticky duration
      section.style.minHeight = `calc(100vh + ${SCROLL_LENGTH}px)`;

      function render() {
        const start = section.offsetTop;
        const y = window.scrollY;
        const delta = Math.min(Math.max(y - start, 0), SCROLL_LENGTH);

        // Reset all
        intro.classList.remove('visible');
        midNote.classList.remove('visible');
        trendRow.classList.remove('visible');
        card1.classList.remove('visible');
        card2.classList.remove('visible');
        card3.classList.remove('visible');
        midNote.setAttribute('aria-hidden', 'true');
        trendRow.setAttribute('aria-hidden', 'true');
        card1.setAttribute('aria-hidden', 'true');
        card2.setAttribute('aria-hidden', 'true');
        card3.setAttribute('aria-hidden', 'true');

        if (delta < 500) {
          intro.classList.add('visible');
        } else if (delta < 1000) {
          midNote.classList.add('visible');
          midNote.setAttribute('aria-hidden', 'false');
        } else {
          trendRow.classList.add('visible');
          trendRow.setAttribute('aria-hidden', 'false');
          // show all three together
          card1.classList.add('visible');
          card2.classList.add('visible');
          card3.classList.add('visible');
          card1.setAttribute('aria-hidden', 'false');
          card2.setAttribute('aria-hidden', 'false');
          card3.setAttribute('aria-hidden', 'false');
        }
      }

      window.addEventListener('scroll', render, { passive: true });
      window.addEventListener('resize', render);
      render();
    }

    // 实现滚动时的视差效果
    function initStickyEffect() {
       const parallaxWrapper = document.querySelector('.parallax-wrapper');
       const parallaxContainer = document.getElementById('parallax-container');
      const earthSection = document.querySelector('.earth-section');
       const earthLayers = document.querySelector('.earth-layers');
       const progressRing = document.querySelector('.progress-ring');
       const progressSections = document.querySelectorAll('.progress-circle');
       const titleTexts = document.querySelectorAll('.title-text');
       const phoneScreens = document.querySelectorAll('.phone-screen');
       
       if (!parallaxWrapper || !parallaxContainer || !earthSection || !earthLayers || !progressRing) return;
       
       // 获取earth-section的底部位置
       const earthSectionBottom = earthSection.offsetTop + earthSection.offsetHeight;
       const viewportHeight = window.innerHeight;
       let hasStartedParallax = false;
      
      function handleScroll() {
        const scrollY = window.scrollY;
         const earthSectionTop = earthSection.offsetTop;
         const earthSectionBottom = earthSectionTop + earthSection.offsetHeight;
         const parallaxStartY = earthSectionBottom;
         const parallaxEndY = parallaxStartY + (viewportHeight * 3);
         
         // 当earth-section完全进入视窗时，显示图像在初始位置
         if (scrollY >= earthSectionTop && scrollY < parallaxStartY) {
           parallaxWrapper.className = 'parallax-wrapper initial';
           earthLayers.classList.remove('hidden'); // 显示原始圆圈
           progressRing.classList.remove('visible'); // 隐藏进度条
           titleTexts.forEach(title => title.classList.remove('visible')); // 隐藏所有标题
           phoneScreens.forEach(screen => screen.classList.remove('active')); // 隐藏所有屏幕
           hasStartedParallax = false;
         }
        // 当进入视差区域时，滑动到中心并隐藏原始圆圈
        else if (scrollY >= parallaxStartY && scrollY <= parallaxEndY) {
          parallaxWrapper.className = 'parallax-wrapper center';
          
          // 一旦开始视差效果，就隐藏原始圆圈并显示进度条
          if (!hasStartedParallax) {
            earthLayers.classList.add('hidden');
            progressRing.classList.add('visible');
            hasStartedParallax = true;
          }
          
          // 每次都重新触发进度条动画
          progressRing.classList.add('visible');
          animateProgressBars();
          
          // 根据滚动进度显示不同的标题
          const progress = (scrollY - parallaxStartY) / (viewportHeight * 3);
          const scale = 1 + (progress * 0.1); // 从1.0轻微缩放到1.1
          parallaxWrapper.style.transform = `translate(-50%, -50%) scale(${scale})`;
          
          // 控制标题显示
          updateTitles(progress);
        }
         // 超过视差区域时，隐藏图像并恢复原始圆圈
         else if (scrollY > parallaxEndY) {
           parallaxWrapper.className = 'parallax-wrapper';
           earthLayers.classList.remove('hidden'); // 恢复显示原始圆圈
           progressRing.classList.remove('visible'); // 隐藏进度条
           titleTexts.forEach(title => title.classList.remove('visible')); // 隐藏所有标题
           phoneScreens.forEach(screen => screen.classList.remove('active')); // 隐藏所有屏幕
           hasStartedParallax = false;
         }
         // 在earth-section之前，完全隐藏图像
         else {
           parallaxWrapper.className = 'parallax-wrapper';
           earthLayers.classList.remove('hidden'); // 确保原始圆圈可见
           progressRing.classList.remove('visible'); // 确保进度条隐藏
           titleTexts.forEach(title => title.classList.remove('visible')); // 隐藏所有标题
           phoneScreens.forEach(screen => screen.classList.remove('active')); // 隐藏所有屏幕
           hasStartedParallax = false;
         }
      }
      
       // 更新标题显示函数
       function updateTitles(progress) {
         const parallaxImage = document.querySelector('.parallax-image');
         const phoneScreens = document.querySelectorAll('.phone-screen');
         
         // 隐藏所有标题
         titleTexts.forEach(title => {
           title.classList.remove('visible');
         });
         
         // 隐藏所有屏幕
         phoneScreens.forEach(screen => {
           screen.classList.remove('active');
         });
         
         // 移除所有颜色类
         parallaxImage.classList.remove('color-bottom', 'color-middle', 'color-top');
         
         // 根据滚动进度显示对应的标题、颜色和屏幕
         if (progress >= 0 && progress < 0.33) {
           // 第一个窗口高度：显示第一个标题 - 蓝色（bottom层）
           titleTexts[0].classList.add('visible');
           phoneScreens[0].classList.add('active'); // 显示第一个屏幕
           changeImageWithTransition('Photo/buttom1.png', 1.2);
           console.log('切换到buttom1图片和屏幕1, progress:', progress);
          } else if (progress >= 0.33 && progress < 0.66) {
            // 第二个窗口高度：显示第二个标题 - 浅紫色（middle层）
            titleTexts[1].classList.add('visible');
            phoneScreens[1].classList.add('active'); // 显示第二个屏幕
            changeImageWithTransition('Photo/buttom2.png', 1.2);
            console.log('切换到buttom2图片和屏幕2, progress:', progress);
          } else if (progress >= 0.66) {
            // 第三个窗口高度：显示第三个标题 - 绿色（top层）
            titleTexts[2].classList.add('visible');
            phoneScreens[2].classList.add('active'); // 显示第三个屏幕
            changeImageWithTransition('Photo/buttom3.png', 1.2);
            console.log('切换到buttom3图片和屏幕3, progress:', progress);
         }
         
         // 调试信息
         console.log('当前进度:', progress, '第三个标题可见:', titleTexts[2].classList.contains('visible'));
       }
       
       // 带过渡效果的图片切换函数
       function changeImageWithTransition(newSrc, scaleSize = 1) {
         const parallaxImage = document.querySelector('.parallax-image');
         if (parallaxImage.src.includes(newSrc) && parallaxImage.style.transform.includes(`scale(${scaleSize})`)) return; // 如果已经是目标图片和缩放，不重复切换
         
         // 淡出
         parallaxImage.style.opacity = '0.3';
         parallaxImage.style.transform = 'scale(0.95)';
         
         setTimeout(() => {
           // 切换图片
           parallaxImage.src = newSrc;
           
           // 淡入并应用缩放
           parallaxImage.style.opacity = '1';
           parallaxImage.style.transform = `scale(${scaleSize})`;
         }, 300); // 300ms后切换图片
       }
      
      // 进度条动画函数
      let animationTimeout;
      function animateProgressBars() {
        // 清除之前的动画
        if (animationTimeout) {
          clearTimeout(animationTimeout);
        }
        
        // 首先重置所有进度条到初始状态
        progressSections.forEach((section) => {
          section.style.strokeDashoffset = '703';
        });
        
        // 然后依次动画每个进度条
        progressSections.forEach((section, index) => {
          setTimeout(() => {
            section.style.strokeDashoffset = '0';
          }, index * 500); // 每个进度条间隔500ms动画
        });
      }
      
      // 初始化时确保图像处于隐藏状态
      parallaxWrapper.className = 'parallax-wrapper';
      
      // 监听滚动事件
      window.addEventListener('scroll', handleScroll);
      
      // 初始检查
      handleScroll();
    }

    // Data URI constants for the three layers
    const LAYER_DATA = {
      bottom: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAAAAAQACAYAAAB/HSuDAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAE3NSURBVHgB7d3LdlzltS/w+a2yfAinsZWmx5bZJRnGSC/mCSI3LHucTswTYJ7A5gkwT4B5AswToHRyZNNAeQKcHmPgSwUrcTO1GwfYlmp9p5YsGd91q8u6/H5jbKpUqthhx4ia/2/O+aUAAGauf+Xh4ju/vrNYPd+JnX71mCP197+fy/z0eUr/kSIWn/+PPv/r5Je+fu4br3/9sFIMXv/yK68PfvstYxg5//fTN6ZhSuOvy3KYijTcfWn82Ct7wx82zrz21wYApisFAHAif7j8uF89VoX8fhG/W8D/Vrz3cx4/pr1C/qTFeXsMx/8/GT4XKgyehQhVgJDLQRUaCA4AYDIEAADwBlVhv1/U7xbwEf/1rKDfP3lXzM9a1U0w2O0uqAKDnP/xfFhwKk4NBAUA8HoCAAA6qSruR8VosSzj/G/FfVXo77beV/+3GDTZXlCQBjnyoOoqSJHvViHBzjs7dwfry8MAgI4RAADQStWM/cKThf5+gT/+F94fx//aWxwXg+fjacGvwOdu1UmQx4/j5/+ougiKU8Vg+/T2QEAAQBsJAABorP1FetsxWt0v8seP53dn7bXmczLVEsMqGNgdM6i6B6pw4Me/Lt0NAGgoAQAAtffSaf4fd1v1n57k9wNm74XOgSLlu8YKAGgCAQAAtaHQp+F2uwaqYCDl8m/VvoF7G2c3AwBqQgAAwFxUS/i2y+3zORX93db9iFWFPi11d3cZYS7/XhSx6aYCAOZFAADA1O0W+0/n9P+4t2l/NSzho9te6BawXwCAWRAAADBRLxb7u63850OxD4fxQiiwUCzc1SkAwCQJAAA4tmpm/9...',
      middle: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAAAAAQACAYAAAB/HSuDAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUACAMZSURBVHgB7P3dsyXJcSeIuUeec++tr/4ApwBi2RSKWIga67EZ9hrN1kz7goJsSe6YyYzAkE3JTCYB86Y3YEd/QHXNHzAg/wGhYbsP0jQwjTGjCQtgbLrwIDM9DDXNh20bURRQGDTRBIpgd6M+7r3nZEbI3SMiT2RkRGaeW99V/uu+dfJkRkZERkac8J+7hweCQqFQKBSKx4Lvvv3BFf5stt1LiO4ly38WXuJzBlGugTEOAa5YcGDoq3P4EgKlc47T0FmgdPRpnSRHyoi+0i3uCvJ152JxfIBJ8S5cx+xaPL7pv8bL8vER3fIR1QmAKhou9+ko5U1rLUqdO/cTucXZj4zBj1r+slpJ2n/6pU/fBIVCoVAoFI8cCAqFQqFQKO4Lb7/945eO4OglaNsrhkg8WvOSa/AzRH9fIv4thB2weZFY+m8FQn0luT0S7hFBD59YSLsIrAwIBH9wPFV2JV0pr7xuS5E+w81eqeBzu0kXPwLrPkaHN50h5YEj5QEpDk7g5KMvfem3PgKFQqFQKBRnhioAFAqFQqGogC30bJ0nInpFSD2SVd2YzzCpZxLvyFqPhi3wPYTc5iQ6s8T36bJ75DixyAMMyXlJITDIM7HoL0JSz5ECIK2PeBX4L7V6lBQTLjREXtbeiO0neVi4iQ3+RDwQRGGAN9nboEN3k9OerNp3VVGgUCgUCkUZqgBQKBQKxXOJaLU33fY1b7GH36FJ8SWisle8Wz2QBb8n8+mtI+I+5WYPY9f6RVb27HyuQCjBFeoHSZmjeub5zigq9oFL8iqVP3kv1J8hbR9XyzvoHX6CBm+6tvvINOZduu0jdN...',
      top: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAAAAAQACAYAAAB/HSuDAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUABqJtSURBVHgB7P1djxxXliWIni/78PBwkpFkSBRb6lSzs1nZjFu4aAg9BdSti+QA8zSoeYwE+u0+9UP/iYj4E/nQf2AAxWPdx7p3mEBPA4WGULioIdHFzuFVtrIoSkEqGPTwcPs658xe+xzz8AiSSkmZKSlTewWdZm5ubm5uEWZ29tprr62UQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgE3zK0EggEAoHgjxM6xjjOR03Ac0yUQCAQCAQCgeAVCAEgEAgEgu8dKJDn+1MO5lNgj1uWVpF+NP4b5/kN+H8t7Nd5cRwX0rq0bJ0wEKJAIBAIBALBDw5OCQQCgUDw/cAqg69zdI8Af/9gn8N7PD/YPzC8Iq+aSIKDgwOt9jGztqW9FPnjtf29vRVpgOd7+3sRn8DvzySCkAECgUAgEAh+CBAFgEAgEAi+U+SsvF7dkWJ6EtdS+jnS12pvP4IQuHv3rj5Uh2rn4U5aaU9dJAAID2idnd2HtD5e31vl/pkw4EV78Xz7WV3wipZAIBAIBAKB4E8HQgAIBAKB4DsDgn8KyA2C8QNF2Xm1t2IDOPNPgf3dw7v6IQXyDw4f6N3dXXV4SIH/9g7fvx4cPbgQrGP5K8t2M0mwRhDsE...'
    };

    // Earth layer interaction functionality
    function initEarthInteraction() {
      const canvases = document.querySelectorAll('.earth-layer');
      const infoItems = document.querySelectorAll('.info-item');
      const earthLayersContainer = document.querySelector('.earth-layers');
      
      // 初始化：显示bottom层内容
      showInfoForLayer('bottom');
      
      // 设置canvas
      setupCanvases();
      
      function setupCanvases() {
        const imageFiles = {
          'bottom': 'Photo/bottom.png',
          'middle': 'Photo/middle.png', 
          'top': 'Photo/top.png'
        };
        
        canvases.forEach(canvas => {
          const layerType = canvas.getAttribute('data-layer');
          const ctx = canvas.getContext('2d');
          
          // 设置canvas尺寸
          canvas.width = 675;
          canvas.height = 675;
          
          // 加载对应的PNG图片
          const img = new Image();
          img.onload = function() {
            // 清空canvas
            ctx.clearRect(0, 0, 675, 675);
            // 绘制图片
            ctx.drawImage(img, 0, 0, 675, 675);
          };
          img.src = imageFiles[layerType];
        });
      }
      
      // 使用mousemove事件来检测鼠标位置
      earthLayersContainer.addEventListener('mousemove', function(e) {
        const rect = this.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // 检查是否在地球范围内
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        const distance = Math.sqrt(
          Math.pow(mouseX - centerX, 2) + Math.pow(mouseY - centerY, 2)
        );
        const radius = rect.width / 2;
        
        if (distance > radius) {
          return; // 鼠标在地球外
        }
        
        // 使用基于区域的检测
        const detectedLayer = detectLayerByRegion(mouseX, mouseY, rect);
        showInfoForLayer(detectedLayer);
      });
      
      function detectLayerByRegion(mouseX, mouseY, rect) {
        // 将鼠标位置转换为相对坐标 (0-1)
        const x = mouseX / rect.width;
        const y = mouseY / rect.height;
        
        // 计算距离中心的相对距离
        const centerX = 0.5;
        const centerY = 0.5;
        const distanceFromCenter = Math.sqrt(
          Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2)
        );
        
        // 使用更精确的区域检测，基于实际图片内容
        // 根据PNG图片的实际布局来优化检测
        
        // 边缘区域 (距离中心 > 40%) - 蓝色海洋
        if (distanceFromCenter > 0.4) {
          return 'bottom';
        }
        // 外围区域 (距离中心 25-40%) - 大陆边缘
        else if (distanceFromCenter > 0.25) {
          // 在特定角度范围内检测大陆
          const angle = Math.atan2(y - centerY, x - centerX);
          const angleDeg = (angle * 180 / Math.PI + 360) % 360;
          
          // 大陆通常在特定角度范围内
          if ((angleDeg > 30 && angleDeg < 150) || 
              (angleDeg > 210 && angleDeg < 330)) {
            return 'middle';
          } else {
            return 'bottom';
          }
        }
        // 中心区域 (距离中心 < 25%) - 城市密集区
        else {
          return 'top';
        }
      }
      
      function showInfoForLayer(layerType) {
        // 隐藏所有文字内容
        infoItems.forEach(item => {
          item.classList.remove('active');
        });
        
        // 显示对应的文字内容
        const targetInfo = document.querySelector(`.info-item[data-layer="${layerType}"]`);
        if (targetInfo) {
          targetInfo.classList.add('active');
        }
        
        // 调试信息（可以在控制台查看）
        console.log('当前显示图层:', layerType);
      }
    }

      // Expandable functionality
      function toggleExpandable(element) {
      const content = element.nextElementSibling;
      const isExpanded = element.classList.contains('expanded');
      
      if (isExpanded) {
        element.classList.remove('expanded');
        content.classList.remove('expanded');
      } else {
        element.classList.add('expanded');
        content.classList.add('expanded');
      }
    }

    // Toggle content with add icon
    function toggleContent(iconElement) {
      const titleElement = iconElement.parentElement;
      const content = titleElement.nextElementSibling;
      const isExpanded = titleElement.classList.contains('expanded');
      
      if (isExpanded) {
        titleElement.classList.remove('expanded');
        content.classList.remove('expanded');
        iconElement.textContent = '+';
      } else {
        titleElement.classList.add('expanded');
        content.classList.add('expanded');
        iconElement.textContent = '−';
      }
    }

    // Row toggle for list
    function toggleRow(btn) {
      const row = btn.closest('.list-row');
      const next = row.nextElementSibling;
      if (!next || !next.classList.contains('list-row-content')) return;
      const isOpen = row.classList.contains('open');
      if (isOpen) {
        row.classList.remove('open');
      } else {
        row.classList.add('open');
      }
    }

    // Random Trip Actions Generator
    const ANGLER_ACTIONS = [
      'Check weather',
      'Target species',
      'Target location',
      'Get fishing license',
      'Verify local regulations',
      'Pack',
      'Prepare bait',
      'Inspect line/leader',
      'Sharpen hooks',
      'Download offline maps',
      'Load waypoints',
      'Check PFDs and safety kit',
      'Confirm boat/kayak condition and fuel/air',
      'Pack cooler, ice, and fish bag',
      'Carry measuring items',
      'Set departure time',
      'Tell someone your plan and ETA',
    ];

    function sampleActions(source, count) {
      const array = [...source];
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array.slice(0, count);
    }

    let CURRENT_ITEMS = [];

    function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh, margin = 8) {
      return !(
        ax + aw + margin <= bx ||
        bx + bw + margin <= ax ||
        ay + ah + margin <= by ||
        by + bh + margin <= ay
      );
    }

    function findNonOverlappingPosition(bw, bh, fieldWidth, fieldHeight, placed, attempts = 200) {
      for (let i = 0; i < attempts; i++) {
        const x = Math.max(0, Math.random() * Math.max(0, fieldWidth - bw));
        const y = Math.max(0, Math.random() * Math.max(0, fieldHeight - bh));
        let ok = true;
        for (let j = 0; j < placed.length; j++) {
          const p = placed[j];
          if (rectsOverlap(x, y, bw, bh, p.x, p.y, p.w, p.h)) {
            ok = false;
            break;
          }
        }
        if (ok) return { x, y };
      }
      return null; // not found
    }

    function renderBubbles(count = 12, presetItems = null) {
      const field = document.getElementById('bubble-field');
      if (!field) {
        console.error('Bubble field not found!');
        return;
      }
      field.innerHTML = '';
      const items = presetItems && presetItems.length ? presetItems : sampleActions(ANGLER_ACTIONS, count);
      CURRENT_ITEMS = items;
      const fieldWidth = field.clientWidth;
      const fieldHeight = field.clientHeight;
      console.log('Field dimensions:', fieldWidth, 'x', fieldHeight);
      
      // Ensure field has valid dimensions
      if (fieldWidth <= 0 || fieldHeight <= 0) {
        console.error('Invalid field dimensions:', fieldWidth, 'x', fieldHeight);
        return;
      }
      const placed = [];
      items.forEach(text => {
        const b = document.createElement('div');
        b.className = 'action-bubble';
        // Randomize bubble size between 100px and 220px
        const size = Math.floor(100 + Math.random() * 120);
        b.style.setProperty('--bubble-size', size + 'px');
        b.textContent = text;
        field.appendChild(b);
        // Measure and place without overlap
        const bw = b.offsetWidth;
        const bh = b.offsetHeight;
        const pos = findNonOverlappingPosition(bw, bh, fieldWidth, fieldHeight, placed, 240);
        if (pos) {
          b.style.left = pos.x + 'px';
          b.style.top = pos.y + 'px';
          console.log('Positioned bubble at:', pos.x, pos.y);
          placed.push({ x: pos.x, y: pos.y, w: bw, h: bh });
        } else {
          console.log('No position found for bubble:', text);
          // Fallback: use simple random positioning
          const fallbackX = Math.random() * Math.max(0, fieldWidth - bw);
          const fallbackY = Math.random() * Math.max(0, fieldHeight - bh);
          b.style.left = fallbackX + 'px';
          b.style.top = fallbackY + 'px';
          console.log('Using fallback position:', fallbackX, fallbackY);
          placed.push({ x: fallbackX, y: fallbackY, w: bw, h: bh });
        }
      });
    }

    function repositionBubbles() {
      const field = document.getElementById('bubble-field');
      if (!field || !CURRENT_ITEMS.length) return;
      renderBubbles(CURRENT_ITEMS.length, CURRENT_ITEMS);
    }

    document.addEventListener('DOMContentLoaded', () => {
      // Add a small delay to ensure the field has proper dimensions
      setTimeout(() => {
        renderBubbles();
      }, 100);
      
      const regen = document.getElementById('regenerate-bubbles');
      if (regen) {
        regen.addEventListener('click', (e) => {
          e.preventDefault();
          renderBubbles();
        });
      }
      window.addEventListener('resize', () => {
        // debounce resize
        clearTimeout(window.__bubbleResizeTimer);
        window.__bubbleResizeTimer = setTimeout(repositionBubbles, 150);
      });
      
      // Initialize jsPlumb for UML diagram
      initJsPlumbUML();
    });

    // Global variable to store UML data
    let umlData = null;

    // Load UML data from JSON file
    async function loadUMLData() {
      try {
        const response = await fetch('uml-data.json');
        umlData = await response.json();
        return umlData;
      } catch (error) {
        console.error('Error loading UML data:', error);
        return null;
      }
    }

    // Generate UML card HTML from data
    function generateUMLCard(cardData) {
      const cardHtml = `
        <div class="uml-card ${cardData.type} ${cardData.gridPosition}" data-uml-id="${cardData.id}">
          <div class="uml-card-header">
            ${cardData.number ? `<span class="uml-number">${cardData.number}</span>` : ''}
            <h3 class="uml-title">${cardData.name}</h3>
          </div>
          <div class="uml-attributes">
            ${cardData.attributes.map(attr => `<div class="uml-attribute">${attr}</div>`).join('')}
          </div>
          <div class="uml-separator"></div>
          <div class="uml-methods">
            ${cardData.methods.map(method => `<div class="uml-method">${method}</div>`).join('')}
          </div>
        </div>
      `;
      return cardHtml;
    }

    // Generate info card HTML from data
    function generateInfoCard(infoData) {
      const cardHtml = `
        <div class="uml-info-card ${infoData.gridPosition}">
          ${infoData.title.map(title => `<h4>${title}</h4>`).join('')}
          <p>${infoData.description}</p>
        </div>
      `;
      return cardHtml;
    }

    // Render UML diagram from JSON data
    function renderUMLDiagram(data) {
      const container = document.getElementById('uml-diagram');
      if (!container || !data) return;

      // Clear existing content
      container.innerHTML = '';

      // Generate UML cards
      data.umlClasses.forEach(cardData => {
        container.insertAdjacentHTML('beforeend', generateUMLCard(cardData));
      });

      // Info cards are now only shown in tooltips, not rendered in grid

      // Attach tooltips from info cards to corresponding UML cards
      try {
        // math-challenge-1 to RecommendationEngine
        const info1 = (data.infoCards || []).find(i => i.id === 'math-challenge-1');
        const recEl = document.querySelector('[data-uml-id="recommendation-engine-01"]');
        if (recEl && info1) {
          const titleText = Array.isArray(info1.title) ? info1.title.join(' ') : (info1.title || '');
          const fullText = `${info1.id}\n\n${titleText}\n\n${info1.description || ''}`.trim();
          recEl.setAttribute('data-tooltip', fullText);
        }

        // math-challenge-2 to ARSession
        const info2 = (data.infoCards || []).find(i => i.id === 'math-challenge-2');
        const arEl = document.querySelector('[data-uml-id="ar-session-01"]');
        if (arEl && info2) {
          const titleText = Array.isArray(info2.title) ? info2.title.join(' ') : (info2.title || '');
          const fullText = `${info2.id}\n\n${titleText}\n\n${info2.description || ''}`.trim();
          arEl.setAttribute('data-tooltip', fullText);
        }

        // math-challenge-3 to EmotionAI
        const info3 = (data.infoCards || []).find(i => i.id === 'math-challenge-3');
        const emotionEl = document.querySelector('[data-uml-id="emotion-ai-01"]');
        if (emotionEl && info3) {
          const titleText = Array.isArray(info3.title) ? info3.title.join(' ') : (info3.title || '');
          const fullText = `${info3.id}\n\n${titleText}\n\n${info3.description || ''}`.trim();
          emotionEl.setAttribute('data-tooltip', fullText);
        }
      } catch (e) {
        console.warn('Failed to attach tooltips from info cards', e);
      }
    }

    // Initialize jsPlumb for interactive UML diagram
    async function initJsPlumbUML() {
      // Load UML data first
      const data = await loadUMLData();
      if (!data) {
        console.error('Failed to load UML data');
        return;
      }

      // Render the diagram
      renderUMLDiagram(data);

      // Wait for jsPlumb to be available
      if (typeof jsPlumb === 'undefined') {
        console.warn('jsPlumb not loaded yet, retrying...');
        setTimeout(initJsPlumbUML, 100);
        return;
      }

      // Initialize jsPlumb instance
      const instance = jsPlumb.newInstance({
        container: "uml-diagram",
        paintStyle: data.settings.connectionStyle,
        hoverPaintStyle: { 
          stroke: data.settings.connectionStyle.hoverStroke, 
          strokeWidth: data.settings.connectionStyle.hoverStrokeWidth 
        },
        connector: ["Flowchart", { curviness: 20 }],
        endpoint: "Blank",
        anchor: "Center",
        overlays: [
          ["Arrow", { width: 10, length: 10, location: 1 }]
        ]
      });
      
      // Enable autosize for all UML elements
      instance.setSuspendDrawing(true);
      
      // Store instance globally for control functions
      window.jsPlumbInstance = instance;

      // Make UML elements draggable
      const umlElements = document.querySelectorAll('.uml-card');
      
      umlElements.forEach(element => {
        // Store original position
        if (!element.getAttribute('data-original-left')) {
          element.setAttribute('data-original-left', element.style.left);
          element.setAttribute('data-original-top', element.style.top);
        }
        
        instance.draggable(element, {
          containment: "parent",
          grid: [data.settings.gridSize, data.settings.gridSize],
          drag: function(event) {
            // Update position during drag
            element.style.left = event.pos[0] + 'px';
            element.style.top = event.pos[1] + 'px';
          }
        });
        
        // Enable autosize for this element
        instance.addToGroup("autosize", element);
      });
      
      // Configure autosize group
      instance.setGroupDefaults("autosize", {
        autoSize: true,
        autoSizePadding: 20
      });
      
      // Resume drawing after autosize setup
      instance.setSuspendDrawing(false);
      
      // Trigger autosize for all elements after content is loaded
      setTimeout(() => {
        umlElements.forEach(element => {
          instance.repaint(element);
        });
      }, 100);

      // Add endpoints and create connections
      /*
      data.connections.forEach(conn => {
        const sourceElement = document.querySelector(`[data-uml-id="${conn.source}"]`);
        const targetElement = document.querySelector(`[data-uml-id="${conn.target}"]`);
        
        if (sourceElement && targetElement) {
          instance.addEndpoint(sourceElement, {
            anchor: "Right",
            isSource: true,
            maxConnections: -1
          });
          
          instance.addEndpoint(targetElement, {
            anchor: "Left", 
            isTarget: true,
            maxConnections: -1
          });
          
          instance.connect({
            source: sourceElement,
            target: targetElement,
            label: conn.label,
            paintStyle: data.settings.connectionStyle,
            overlays: [
              ["Arrow", { width: 10, length: 10, location: 1 }],
              ["Label", { label: conn.label, location: 0.5, cssClass: "connection-label" }]
            ]
          });
        }
      });
      */

      // Add click handlers for interactive features
      umlElements.forEach(element => {
        element.addEventListener('click', function() {
          // Highlight connected elements
          const connections = instance.getConnections({ source: this });
          const targetConnections = instance.getConnections({ target: this });
          
          // Reset all elements
          umlElements.forEach(el => el.classList.remove('highlighted'));
          
          // Highlight current element
          this.classList.add('highlighted');
          
          // Highlight connected elements
          [...connections, ...targetConnections].forEach(conn => {
            if (conn.source === this) {
              conn.target.classList.add('highlighted');
            } else {
              conn.source.classList.add('highlighted');
            }
          });
        });
      });

      console.log('jsPlumb UML diagram initialized successfully from JSON data');
    }

    // UML Control Functions
    async function reloadUMLData() {
      console.log('Reloading UML data...');
      await initJsPlumbUML();
    }

    function resetUMLDiagram() {
      const umlElements = document.querySelectorAll('.uml-card');
      umlElements.forEach(element => {
        // Reset position to original coordinates
        const originalLeft = element.getAttribute('data-original-left') || element.style.left;
        const originalTop = element.getAttribute('data-original-top') || element.style.top;
        element.style.left = originalLeft;
        element.style.top = originalTop;
        element.style.transform = 'none';
        element.classList.remove('highlighted');
        
        // Store original position if not already stored
        if (!element.getAttribute('data-original-left')) {
          element.setAttribute('data-original-left', originalLeft);
          element.setAttribute('data-original-top', originalTop);
        }
      });
      
      // Reset jsPlumb instance if available
      if (window.jsPlumbInstance) {
        window.jsPlumbInstance.repaintEverything();
      }
    }

    function toggleConnections() {
      const connectors = document.querySelectorAll('.jtk-connector');
      const isVisible = connectors[0]?.style.display !== 'none';
      
      connectors.forEach(connector => {
        connector.style.display = isVisible ? 'none' : 'block';
      });
      
      // Also toggle connection labels
      const labels = document.querySelectorAll('.jtk-overlay');
      labels.forEach(label => {
        label.style.display = isVisible ? 'none' : 'block';
      });
    }

    function exportDiagram() {
      const container = document.querySelector('.uml-diagram-container');
      if (container) {
        // Use html2canvas to capture the HTML elements
        if (typeof html2canvas !== 'undefined') {
          html2canvas(container, {
            backgroundColor: '#ffffff',
            scale: 2,
            useCORS: true,
            allowTaint: true
          }).then(canvas => {
            const link = document.createElement('a');
            link.download = 'uml-diagram.png';
            link.href = canvas.toDataURL();
            link.click();
          });
        } else {
          // Fallback: create a simple screenshot using canvas
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = container.offsetWidth;
          canvas.height = container.offsetHeight;
          
          // Fill background
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Draw a simple representation
          ctx.fillStyle = '#000000';
          ctx.font = '16px Arial';
          ctx.fillText('UML Diagram Export', 50, 50);
          ctx.fillText('Please use browser screenshot tools for better results', 50, 80);
          
          const link = document.createElement('a');
          link.download = 'uml-diagram.png';
          link.href = canvas.toDataURL();
          link.click();
        }
      }
    }

  </script>
</body>
</html>

